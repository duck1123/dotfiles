{:tasks
 {:requires ([babashka.fs :as fs]
             [clojure.edn :as edn]
             [clojure.string :as str])

  build
  {:doc     "Build the current configurations"
   :depends [build-home build-os]}

  build-all
  {:doc  "build all configurations"
   :task (shell "nom build .#ci")}

  build-all-home
  {:doc     "Build all home configurations"
   :depends [build-home-inspernix build-home-nasnix build-home-powerspecnix
             build-home-steamdeck build-home-vallen]}

  build-all-os
  {:doc     "Build all nixos configurations"
   :depends [build-os-inspernix build-os-nasnix build-os-powerspecnix]}

  build-home
  {:doc  "Build the current home configuration"
   :task (shell "nh home build .")}

  build-home-edgenix
  {:task
   (let [trace? false
         cmd    "nh home build .#homeConfigurations.duck@edgenix.activationPackage"
         cmd    (str cmd (when trace? " -- --show-trace"))]
     (binding [*out* *err*] (println cmd))
     (shell cmd))}

  build-home-inspernix
  {:task
   (let [trace? false
         cmd    "nh home build .#homeConfigurations.duck@inspernix.activationPackage"
         cmd    (str cmd (when trace? " -- --show-trace"))]
     (binding [*out* *err*] (println cmd))
     (shell cmd))}

  build-home-nasnix
  {:task
   (let [trace? false
         cmd    "nh home build .#homeConfigurations.duck@nasnix.activationPackage"
         cmd    (str cmd (when trace? " -- --show-trace"))]
     (binding [*out* *err*] (println cmd))
     (shell cmd))}

  build-home-powerspecnix
  {:task
   (let [trace? false
         cmd    "nh home build .#homeConfigurations.duck@powerspecnix.activationPackage"
         cmd    (str cmd (when trace? " -- --show-trace"))]
     (binding [*out* *err*] (println cmd))
     (shell cmd))}

  build-home-steamdeck
  {:task
   (let [trace? false
         cmd    "nh home build .#homeConfigurations.deck@steamdeck.activationPackage"
         cmd    (str cmd (when trace? " -- --show-trace"))]
     (binding [*out* *err*] (println cmd))
     (shell cmd))}

  build-home-vallen
  {:task
   (let [trace? false
         cmd    "nh home build .#homeConfigurations.drenfer@VAVIRL-PW0BWNQ8.activationPackage"
         cmd    (str cmd (when trace? " -- --show-trace"))]
     (binding [*out* *err*] (println cmd))
     (shell cmd))}

  build-home-vidcentre
  {:task
   (let [trace? false
         cmd    "nh home build .#homeConfigurations.duck@vidcentre.activationPackage"
         cmd    (str cmd (when trace? " -- --show-trace"))]
     (binding [*out* *err*] (println cmd))
     (shell cmd))}

  build-os
  {:task (shell "nh os build .")}

  build-os-edgenix
  {:task
   (let [trace? false
         cmd    "nh os build .#nixosConfigurations.edgenix"
         cmd    (str cmd (when trace? " -- --show-trace"))]
     (binding [*out* *err*] (println cmd))
     (shell cmd))}

  build-os-inspernix
  {:task
   (let [trace? false
         cmd    "nh os build .#nixosConfigurations.inspernix"
         cmd    (str cmd (when trace? " -- --show-trace"))]
     (binding [*out* *err*] (println cmd))
     (shell cmd))}

  build-os-nasnix
  {:task
   (let [trace? false
         cmd    "nh os build .#nixosConfigurations.nasnix"
         cmd    (str cmd (when trace? " -- --show-trace"))]
     (binding [*out* *err*] (println cmd))
     (shell cmd))}

  build-os-powerspecnix
  {:task
   (let [trace? false
         cmd    "nh os build .#nixosConfigurations.powerspecnix"
         cmd    (str cmd (when trace? " -- --show-trace"))]
     (binding [*out* *err*] (println cmd))
     (shell cmd))}

  build-os-vidcentre
  {:task
   (let [trace? false
         cmd    "nh os build .#nixosConfigurations.vidcentre"
         cmd    (str cmd (when trace? " -- --show-trace"))]
     (binding [*out* *err*] (println cmd))
     (shell cmd))}

  check
  {:doc  "Run validation on the project"
   :task (shell "nix flake check")}

  ci
  {:doc     "Build all targets"
   :depends [check build-all]}

  format
  {:doc  "Format all .nix files using nixpkgs-fmt"
   :task (shell "find . -name '*.nix' -exec nixfmt {} +")}

  install-cert-manager
  {:task
   (let [version "1.14.4"
         url     (format "https://github.com/cert-manager/cert-manager/releases/download/v%s/cert-manager.yaml"
                         version)]
     (shell (format "kubectl apply -f %s" url)))}

  list-secret-keys
  {:description "List gpg secret keys"
   :task        (shell "gpg --list-secret-keys --keyid-format=long")}

  make-chart-repo
  {:description "Install repo into cluster"
   :task
   (do
     (println "make chart repo")
     (let [name ""
           url  ""
           data {:apiVersion "catalog.cattle.io/v1"
                 :kind       "ClusterRepo"
                 :metadata   {:name name}
                 :spec       {:url url}}]
       data))}

  read-windows-key
  {:description "Read windows key from firmware"
   :task
   (shell "sudo grep -Eao '(-?[A-Z0-9]{5}){5}' /sys/firmware/acpi/tables/MSDM")}

  switch
  {:depends [switch-home switch-os]}

  switch-home
  {:decription "Update home-manager from flake"
   :task       (shell "nh home switch . -b backup")}

  switch-os
  {:decription "Update nixos from flake (builds and activates immediately)"
   :task       (shell "nh os switch .")}

  boot-os
  {:decription "Build nixos config and set as boot default (activates on reboot, avoids activation timeouts)"
   :task       (shell "nh os boot .")}

  ;; Remote deployment tasks (build locally, push to remote)
  switch-remote
  {:doc     "Switch both NixOS and home-manager on edgenix and nasnix"
   :depends [switch-remote-edgenix switch-remote-nasnix]}

  switch-remote-edgenix
  {:doc  "Switch both NixOS and home-manager on edgenix (builds locally, pushes to remote)"
   :depends [switch-remote-os-edgenix switch-remote-home-edgenix]}

  switch-remote-nasnix
  {:doc  "Switch both NixOS and home-manager on nasnix (builds locally, pushes to remote)"
   :depends [switch-remote-os-nasnix switch-remote-home-nasnix]}

  ;; Build-only tasks (use nom for better progress display)
  build-remote-os-edgenix
  {:doc  "Build NixOS config for edgenix locally using nom (no activation)"
   :task (shell "nom build .#nixosConfigurations.edgenix.config.system.build.toplevel")}

  build-remote-os-nasnix
  {:doc  "Build NixOS config for nasnix locally using nom (no activation)"
   :task (shell "nom build .#nixosConfigurations.nasnix.config.system.build.toplevel")}

  ;; Show package changes (diff current vs new system)
  diff-remote-os-edgenix
  {:doc  "Show package changes between current edgenix system and new build"
   :task (do
           (println "Building new NixOS configuration for edgenix...")
           (shell "sh -c 'nom build .#nixosConfigurations.edgenix.config.system.build.toplevel --no-link --print-out-paths 2>&1 | grep -E \"^/nix/store\" | tail -1 > /tmp/edgenix-new-system.txt'")
           (shell {:extra-env {"NIX_SSHOPTS" "-t"}} "sh -c \"ssh edgenix 'readlink -f /nix/var/nix/profiles/system' > /tmp/edgenix-current-system.txt 2>&1\"")
           (let [new-system (str/trim (slurp "/tmp/edgenix-new-system.txt"))
                 current-system (str/trim (slurp "/tmp/edgenix-current-system.txt"))]
             (if (and new-system current-system (not= new-system "") (not= current-system "") (str/starts-with? new-system "/nix/store") (str/starts-with? current-system "/nix/store"))
               (do
                 (println "\n=== Package Changes ===")
                 (println (str "Current: " current-system))
                 (println (str "New:     " new-system "\n"))
                 (shell (str "nix store diff-closures " current-system " " new-system)))
               (do
                 (println "ERROR: Could not determine system paths")
                 (println (str "New system path: " (if new-system new-system "empty")))
                 (println (str "Current system path: " (if current-system current-system "empty")))))))}

  diff-remote-os-nasnix
  {:doc  "Show package changes between current nasnix system and new build"
   :task (do
           (println "Building new NixOS configuration for nasnix...")
           (shell "sh -c 'nom build .#nixosConfigurations.nasnix.config.system.build.toplevel --no-link --print-out-paths 2>&1 | grep -E \"^/nix/store\" | tail -1 > /tmp/nasnix-new-system.txt'")
           (shell {:extra-env {"NIX_SSHOPTS" "-t"}} "sh -c \"ssh nasnix 'readlink -f /nix/var/nix/profiles/system' > /tmp/nasnix-current-system.txt 2>&1\"")
           (let [new-system (str/trim (slurp "/tmp/nasnix-new-system.txt"))
                 current-system (str/trim (slurp "/tmp/nasnix-current-system.txt"))]
             (if (and new-system current-system (not= new-system "") (not= current-system "") (str/starts-with? new-system "/nix/store") (str/starts-with? current-system "/nix/store"))
               (do
                 (println "\n=== Package Changes ===")
                 (println (str "Current: " current-system))
                 (println (str "New:     " new-system "\n"))
                 (shell (str "nix store diff-closures " current-system " " new-system)))
               (do
                 (println "ERROR: Could not determine system paths")
                 (println (str "New system path: " (if new-system new-system "empty")))
                 (println (str "Current system path: " (if current-system current-system "empty")))))))}

  build-remote-home-edgenix
  {:doc  "Build home-manager activation package for edgenix locally using nom (no activation)"
   :task (shell "nom build .#homeConfigurations.duck@edgenix.activationPackage")}

  build-remote-home-nasnix
  {:doc  "Build home-manager activation package for nasnix locally using nom (no activation)"
   :task (shell "nom build .#homeConfigurations.duck@nasnix.activationPackage")}

  ;; Dry-run tasks (show what would change without applying)
  dry-run-remote-os-edgenix
  {:doc  "Show what would change on edgenix without applying (dry-run, prompts for sudo password)"
   :task (shell {:extra-env {"NIX_SSHOPTS" "-t"}} "nixos-rebuild dry-activate --flake .#edgenix --target-host edgenix --build-host localhost --sudo --ask-sudo-password")}

  dry-run-remote-os-nasnix
  {:doc  "Show what would change on nasnix without applying (dry-run, prompts for sudo password)"
   :task (shell {:extra-env {"NIX_SSHOPTS" "-t"}} "nixos-rebuild dry-activate --flake .#nasnix --target-host nasnix --build-host localhost --sudo --ask-sudo-password")}

  ;; Switch tasks (build with nom first, then copy and activate)
  switch-remote-os-edgenix
  {:doc  "Build NixOS config locally with nom, then copy and switch on edgenix (prompts for sudo password)"
   :task (do
           (println "Building NixOS configuration for edgenix with nom...")
           (shell "sh -c 'nom build .#nixosConfigurations.edgenix.config.system.build.toplevel --no-link --print-out-paths 2>&1 | grep -E \"^/nix/store\" | tail -1 > /tmp/edgenix-system-path.txt'")
           (let [system-path (str/trim (slurp "/tmp/edgenix-system-path.txt"))]
             (if (and system-path (str/starts-with? system-path "/nix/store"))
               (do
                 (println (str "Copying system to edgenix: " system-path))
                 (shell (str "nix copy --to ssh://edgenix " system-path))
                 (println "Activating on edgenix (will prompt for sudo password)...")
                 (shell (str "ssh -t edgenix 'sudo nix-env -p /nix/var/nix/profiles/system --set " system-path " && sudo " system-path "/bin/switch-to-configuration switch'")))
               (println "ERROR: Failed to build or get system path"))))}

  switch-remote-os-nasnix
  {:doc  "Build NixOS config locally with nom, then copy and switch on nasnix (prompts for sudo password)"
   :task (do
           (println "Building NixOS configuration for nasnix with nom...")
           (shell "sh -c 'nom build .#nixosConfigurations.nasnix.config.system.build.toplevel --no-link --print-out-paths 2>&1 | grep -E \"^/nix/store\" | tail -1 > /tmp/nasnix-system-path.txt'")
           (let [system-path (str/trim (slurp "/tmp/nasnix-system-path.txt"))]
             (if (and system-path (str/starts-with? system-path "/nix/store"))
               (do
                 (println (str "Copying system to nasnix: " system-path))
                 (shell (str "nix copy --to ssh://nasnix " system-path))
                 (println "Activating on nasnix (will prompt for sudo password)...")
                 (shell (str "ssh -t nasnix 'sudo nix-env -p /nix/var/nix/profiles/system --set " system-path " && sudo " system-path "/bin/switch-to-configuration switch'")))
               (println "ERROR: Failed to build or get system path"))))}

  switch-remote-home-edgenix
  {:doc  "Build home-manager activation package locally, copy to edgenix, and activate"
   :task (do
           (println "Building home-manager activation package for edgenix...")
           (shell (str "sh -c 'nom build .#homeConfigurations.duck@edgenix.activationPackage --no-link --print-out-paths 2>&1 | grep -E \"^/nix/store\" | tail -1 > /tmp/edgenix-home-path.txt'"))
           (let [activation-path (str/trim (slurp "/tmp/edgenix-home-path.txt"))]
             (if (and activation-path (str/starts-with? activation-path "/nix/store"))
               (do
                 (println (str "Copying to edgenix: " activation-path))
                 (shell (str "nix copy --to ssh://edgenix " activation-path))
                 (println "Activating on edgenix...")
                 (shell (str "ssh edgenix " activation-path "/activate")))
               (println "ERROR: Failed to build activation package or invalid path"))))}

  switch-remote-home-nasnix
  {:doc  "Build home-manager activation package locally, copy to nasnix, and activate"
   :task (do
           (println "Building home-manager activation package for nasnix...")
           (shell (str "sh -c 'nom build .#homeConfigurations.duck@nasnix.activationPackage --no-link --print-out-paths 2>&1 | grep -E \"^/nix/store\" | tail -1 > /tmp/nasnix-home-path.txt'"))
           (let [activation-path (str/trim (slurp "/tmp/nasnix-home-path.txt"))]
             (if (and activation-path (str/starts-with? activation-path "/nix/store"))
               (do
                 (println (str "Copying to nasnix: " activation-path))
                 (shell (str "nix copy --to ssh://nasnix " activation-path))
                 (println "Activating on nasnix...")
                 (shell (str "ssh nasnix " activation-path "/activate")))
               (println "ERROR: Failed to build activation package or invalid path"))))}

  k3d-create-registry
  {:task
   (shell "k3d registry create myregistry.localtest.me --port 12345")}

  k3d-create
  {:description "Create a k3d cluster"
   :task
   (let [dry-run?         false
         use-ingress      false
         create-registry? false
         use-registry?    true
         api-port         6550
         registry-name    "registry"
         registry-host    "k3d-myregistry.localtest.me:12345"
         server-count     1
         cmd              (clojure.string/join
                           " "
                           ["k3d cluster create"
                            "--api-port" api-port
                            "-p \"80:80@loadbalancer\""
                            "-p \"443:443@loadbalancer\""
                            (when-not use-ingress "--k3s-arg \"--disable=traefik@server:0\"")
                            "--servers" server-count
                            (when create-registry?
                              (str "--registry-create " registry-name))
                            (when use-registry?
                              (str "--registry-use " registry-host))
                            "--kubeconfig-update-default"])]
     (if dry-run?
       (println cmd)
       (shell cmd)))}

  k3d-delete
  {:description "Delete k3d cluster"
   :task        (shell "k3d cluster delete k3s-default")}

  k3d-start
  {:doc  "Start the k3s cluster"
   :task (shell "k3d cluster start")}

  k3d-stop
  {:doc  "Stop the k3s cluster"
   :task (shell "k3d cluster stop")}

  install-argocd
  {:doc "Install ArgoCD into the current cluster"
   :task
   (do
     (println "Installing argocd")
     (let [dry-run? false
           url      "https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml"
           commands ["kubectl create namespace argocd"
                     (str "kubectl apply -n argocd -f " url)]]
       (doseq [command commands]
         (if dry-run?
           (println command)
           (shell command)))))}

  install-charts
  {:task
   (let [dry-run? false]
     (doseq [{:keys [name url]} (edn/read-string (slurp "./helm_charts.edn"))]
       (let [command (str "helm repo add " name " " url)]
         (if dry-run?
           (println (str "[DRY-RUN] " command))
           (shell command)))))}

  install-consul
  {:task
   (let [replicas     1
         ingress-host "consul.localhost"]
     (shell
      (clojure.string/join
       " "
       ["consul-k8s install "
        (str "--set server.replicas=" replicas)
        "--set ui.ingress.enabled=true "
        (format "--set \"ui.ingress.hosts[0].host=%s\"" ingress-host)
        "--set \"ui.ingress.hosts[0].paths[0]=/\""
        "--set connectInject.enabled=true"
        "--set connectInject.default=true"
        "--set controller.enabled=true"])))}

  install-rancher
  {:task
   (let [namespace     "cattle-system"
         hostname      "rancher.dev.kronkltd.net"
         email         "duck@kronkltd.net"
         replica-count 1
         cmd           (clojure.string/join
                        " "
                        ["helm install rancher rancher-latest/rancher "
                         (format "--namespace %s" namespace)
                         (format "--set hostname=%s" hostname)
                         (format "--set replicas=%s" replica-count)
                         (format "--set ingress.tls.source=%s" "letsEncrypt")
                         (format "--set letsEncrypt.email=%s" email)])]
     (println cmd)
     (shell cmd))}

  install-traefik
  {:task (shell "helm install traefik traefik/traefik")}

  show-ports
  {:task (shell "netstat -ltnp")}

  update-nix
  {:task (shell "nix-channel --update")}

  watch-namespaces
  {:task (shell "watch kubectl get namespaces")}

  watch-pods
  {:task (shell "watch kubectl get pods --all-namespaces")}

  wipe-k3s
  {:doc  "Wipe k3s directories"
   :task (do
           (shell "sudo rm -rf /etc/rancher/k3s")
           (shell "sudo rm -rf /var/lib/rancher/k3s"))}}}
